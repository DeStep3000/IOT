<h1 align="center">Документация</h1>

*Здесь будет документация нашего проекта*
## Содержание
- [Математическая часть](#математическая-часть)
- - [Point](#point)
- - [Функции](#функции)
- - [Класс Polygon](#класс-polygon)
- - [Класс PolygonField](#класс-polygonfield)
- [Работа с файлами](#работа-с-файлами)
- [Графическая часть](#графическая_часть)
- - [Библиотеки](#библиотеки)
- - [Picture](#picture)
- - [Функции](#функции-1)

# Математическая часть
Эта часть описывает работу с  Polygon.cpp, Polygon.h.

# Point

Point - структура, представляющая собой точку и состоящей из двух полей типа ```double```:
```c++
struct Point {
    double x, y;
};
```
Для неё реализованы операторы сложения, вычитания ```+-```, скалярное произведение ```*```, векторное умножение ```^```, различные операторы сравнения ```== > <``` и оператор вывода ```<<```.

### Пример:
```c++
Point a{2, 3};//создаем точку A(2, 3)
Point b{1, 6};//создаем точку B(1, 6)
std::cout << (a+b) << std::endl;//Вывод: 3 9
std::cout << (a==b) << std::endl;//Вывод: 0
std::cout << (a*b) << std::endl;//Вывод: 20
std::cout << (a^b) << std::endl;//Вывод: 9
```
## Функции
В проекте есть три простые математические функции:
- длина вектора ```double length(Point a);```
- функция знака ```int sign(double a);```
- модуль числа ```double abs_d(double a);```

# Класс Polygon
Данный класс реализует оболочку для многоугольника. **Многоугольник считается выпуклым!** Он имеет два приватных поля: массив вершин многоугольника - ```std::vector<Point> vertices;```, число вершин - ```int num_vertices;```. Для получения доступа можно воспользоваться функциями:
```c++
Polygon pn;
/*...
здесь добавляем точки
...*/
pn.get_vertices();
pn.get_num_vertices();
```
Для того, чтобы добавить точки в многоугольник можно воспользоваться несколькими способами:

- #### Добавление точки напрямую
```c++
Polygon pn;
Point a{2, 3};
pn.input_vertex(a);
pn.print_vertices();//вывод: 2 3
```

- #### Добавление точек через массив
```c++
Polygon pn;
std::vector<double> coordinates = [1, 2, 3, 4, 5, 6];
pn.input_from_array(coordinates);
pn.print_vertices();//вывод: 1 2  3 4  5 6
```

- #### Добавление точек из строки
```c++
Polygon pn;
const std::string input = "03 2 4 1 2 3 4";
pn.input_from_file(input, 0);//второй параметр отвечает за индекс, начиная с которого будет осуществляться поиск *0x*
pn.print_vertices();//вывод: 2 4  1 2  3 4
```
***Внимание! добавить одинаковые точки в многоугольник не получится, повторная точка просто не добавится***

Для проверки не является ли многоугольник пустым, можно использовать функцию:
```с++
Polygon pn;
std::cout << pn.is_empty() << std::endl;//Вывод: 1
//Значит многоугольник действительно пустой
```
Для проверки является ли точка вершиной, можно использовать метод:
```c++
Polygon pn;
Point a{2, 3};
Point b{2, 3};
Point c{1, 0};
pn.input_vertex(a);
std::cout << pn.is_point_vertex(a) << std::endl;//Вывод: 1
std::cout << pn.is_point_vertex(b) << std::endl;//Вывод: 1
std::cout << pn.is_point_vertex(c) << std::endl;//Вывод: 0
```
***Все вычисления производятся с погрешностью eps ~ 10^-13, поэтому точка a{2+eps, 3} была бы признана точкой многоугольника***

Для проверки находится ли точка внутри многоугольника или на его ребре, используйте следующие методы:
```c++
Polygon pn;
Point a{1, 1};
Point b{2, 3};
Point c{3, 1};
Point d{2, 2};
pn.input_vertex(a);
pn.input_vertex(b);
pn.input_vertex(c);
std::cout << pn.is_point_in_f(c) << std::endl;//Вывод: 1
std::cout << pn.is_point_on_edge(c) << std::endl;//Вывод: 0
```

# Класс PolygonField
Этот класс представляет как бы массив, "поле" многоугольников. Он также имеет два приватных поля: массив многоугольников - ```std::vector<Polygon> field;```, число вершин - ```int num_pn;```. Для получения доступа к ним используйте:
```c++
PolygonField pn_field;
/*...
здесь добавляем многоугольники в pn_field
*/
pn_field.get_field();
pn.field.get_num_pn();
```
Добавить многоугольники можно двумя способами:

- #### Добавить напрямую:
```c++
Polygon pn;
/*
здесь добавляем точки в pn
*/
PolygonField pn_field;
pn_field.input_polygon(pn)
```

- #### Добавить из строки:
```c++
const std::string input = "03 2 4 1 2 3 4 03 1 2 3 4 5 6";
PolygonField pn_field;
pn_field.input_polygons(input);
pn_field.print_field;
/*Вывод: Polygon field(2):
2 4  1 2  3 4
1 2  3 4  5 6
*/
```

Для того, чтобы проверить находится ли многоугольник в поле можно воспользоваться функцией:
```c++
pn_field.is_polygon_in_field(pn);
```

Если вы хотите найти пересечение двух многоугольников, воспользуйтесь функцией:
```c++
Polygon res;
Polygon p1;// 1 1 2 2 3 1
Polygon p2;// 2 1 2 2 4 1
PolygonField pn_field;
res = pn_field.intersect_polygons(p1, p2);
res.print_vertices();//Вывод: 2 1 2 2 3 1
```
*Примечание: многоугольники необязательно должны быть членами PolygonField*

Для пересечения поля многоугольников, используйте:
```c++
PolygonField pn_field;
pn_field.intersect_polygon_field();
pn_field.print_field();//Выведутся все многоугольники, получившиеся в результате попарного пересечения
```
Для нахождения итогового пересечения поля многоугольников, используйте:
```c++
PolygonField pn_field;
Polygon res;
res = pn_field.intersect_polygon_field_final();
res.print_vertices();//В выводе будет один из многоугольников с наибольшим количеством пересечений
```
# Работа с файлами
*Здесь будет описание работы с файлами*

Эта часть описывает работу с файлами readfile.cpp и readfile.h
Функции, реализованные здесь, считывают данные из файла и возвращают массив вершин.
В начале объявлются ключи, после которых следуют координаты вершин и строковые значения всех цифр:
```c++
const std::vector<std::string> KEY = {" 03 ", " 04 ", " 05 ", " 06 ", " 07 ", " 08 ", " 09 "};//word that used for cutting coords
const std::string NUMBERS = "0123456789";//numbers that used to find first number after key
```
Далее объявлена стандартная функция считывания данных из файла:
```c++
std::string read_file(const std::string &path);
```
Также присутсвует функция, для обрабатывания входных данных(замена \n на пробел, добавление пробелов в начале и конце строки и удаление повторяющихся пробелов). Нужно для более удобной работы с этими значениями:
```c++
std::string edit_file(std::string input);
```
Для поиска индекса ключа используйте:
```c++
std::size_t find_key(const std::string &path, std::size_t index = 0);//второй параметр- индекс, с которого мы ищем наш ключ
```
Для возвращения вектора координат используйте:
```c++
std::vector<double> fill_coords_from_input(const std::string &input, std::size_t previous_index);//второй параметр- индекс ключа
```
Для финальной обработки вектора координат(нечетное количество координат, пустота вектора) используйте:
```c++
std::vector<double> get_coords(const std::string &path, std::size_t index = 0);//второй параметр- индекс ключа
```
# Графическая часть
Эта часть описывает работу с  sfml.cpp, sfml.h.

# Библиотеки
В графической части были использованы ```SFML``` для отрисовки окон и многоугольников на нём и ```wxWidgets``` для использования файлового менеджера.

# Picture
Picture - это класс, который имеет реализацию для отрисовки экрана, сетки, многоугольников и иконки приложения.

# Функции
- ```void draw_window(std::vector<Polygon> start_vertices, std::vector <Point> final_vertices)``` - отрисовка окна и всех фигур. Принмает вектор многоугольников и вектор точек получившегося прямоугольника
- ```sf::ConvexShape draw_polygon(std::vector<Point> arbitraryPoints, sf::Color color_pol, sf::Color tick);``` - отрисовка многоугольгика. На вход подается вектор точек, цвет многоугольника и цвет оконтовки
- ```float scale(std::vector<Polygon> start_vertices, std::vector<Point> final_vertices);``` - вычисление масштаба для многоугольников