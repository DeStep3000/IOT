<h1 align="center">Документация</h1>

*Здесь будет документация нашего проекта*
## Содержание
- [Математическая часть](#математическая-часть)
- - [Point](#point)
- - [Функции](#функции)
- - [Класс Polygon](#класс-polygon)
- - [Класс PolygonField](#класс-polygonfield)
- [Работа с файлами](#работа-с-файлами)

# Математическая часть
Эта часть описывает работу с  Polygon.cpp, Polygon.h.

# Point

Point - структура, представляющая собой точку и состоящей из двух полей типа ```double```:
```c++
struct Point {
    double x, y;
};
```
Для неё реализованы операторы сложения, вычитания ```+-```, скалярное произведение ```*```, векторное умножение ```^```, различные операторы сравнения ```== > <``` и оператор вывода ```<<```.

### Пример:
```c++
Point a{2, 3};//создаем точку A(2, 3)
Point b{1, 6};//создаем точку B(1, 6)
std::cout << (a+b) << std::endl;//Вывод: 3 9
std::cout << (a==b) << std::endl;//Вывод: 0
std::cout << (a*b) << std::endl;//Вывод: 20
std::cout << (a^b) << std::endl;//Вывод: 9
```
## Функции
В проекте есть три простые математические функции:
- длина вектора ```double length(Point a);```
- функция знака ```int sign(double a);```
- модуль числа ```double abs_d(double a);```

# Класс Polygon
Данный класс реализует оболочку для многоугольника. **Многоугольник считается выпуклым!** Он имеет два приватных поля: массив вершин многоугольника - ```std::vector<Point> vertices;```, число вершин - ```int num_vertices;```. Для получения доступа можно воспользоваться функциями:
```c++
Polygon pn;
/*...
здесь добавляем точки
...*/
pn.get_vertices();
pn.get_num_vertices();
```
Для того, чтобы добавить точки в многоугольник можно воспользоваться несколькими способами:

- #### Добавление точки напрямую
```c++
Polygon pn;
Point a{2, 3};
pn.input_vertex(a);
pn.print_vertices();//вывод: 2 3
```

- #### Добавление точек через массив
```c++
Polygon pn;
std::vector<double> coordinates = [1, 2, 3, 4, 5, 6];
pn.input_from_array(coordinates);
pn.print_vertices();//вывод: 1 2  3 4  5 6
```

- #### Добавление точек из строки
```c++
Polygon pn;
const std::string input = "03 2 4 1 2 3 4";
pn.input_from_file(input, 0);//второй параметр отвечает за индекс, начиная с которого будет осуществляться поиск *0x*
pn.print_vertices();//вывод: 2 4  1 2  3 4
```
***Внимание! добавить одинаковые точки в многоугольник не получится, повторная точка просто не добавится***

Для проверки не является ли многоугольник пустым, можно использовать функцию:
```с++
Polygon pn;
std::cout << pn.is_empty() << std::endl;//Вывод: 1
//Значит многоугольник действительно пустой
```
Для проверки является ли точка вершиной, можно использовать метод:
```c++
Polygon pn;
Point a{2, 3};
Point b{2, 3};
Point c{1, 0};
pn.input_vertex(a);
std::cout << pn.is_point_vertex(a) << std::endl;//Вывод: 1
std::cout << pn.is_point_vertex(b) << std::endl;//Вывод: 1
std::cout << pn.is_point_vertex(c) << std::endl;//Вывод: 0
```
***Все вычисления производятся с погрешностью eps ~ 10^-13, поэтому точка a{2+eps, 3} была бы признана точкой многоугольника***

Для проверки находится ли точка внутри многоугольника или на его ребре, используйте следующие методы:
```c++
Polygon pn;
Point a{1, 1};
Point b{2, 3};
Point c{3, 1};
Point d{2, 2};
pn.input_vertex(a);
pn.input_vertex(b);
pn.input_vertex(c);
std::cout << pn.is_point_in_f(c) << std::endl;//Вывод: 1
std::cout << pn.is_point_on_edge(c) << std::endl;//Вывод: 0
```

# Класс PolygonField
Этот класс представляет как бы массив, "поле" многоугольников. Он также имеет два приватных поля: массив многоугольников - ```std::vector<Polygon> field;```, число вершин - ```int num_pn;```. Для получения доступа к ним используйте:
```c++
PolygonField pn_field;
/*...
здесь добавляем многоугольники в pn_field
*/
pn_field.get_field();
pn.field.get_num_pn();
```
Добавить многоугольники можно двумя способами:

- #### Добавить напрямую:
```c++
Polygon pn;
/*
здесь добавляем точки в pn
*/
PolygonField pn_field;
pn_field.input_polygon(pn)
```

- #### Добавить из строки:
```c++
const std::string input = "03 2 4 1 2 3 4 03 1 2 3 4 5 6";
PolygonField pn_field;
pn_field.input_polygons(input);
pn_field.print_field;
/*Вывод: Polygon field(2):
2 4  1 2  3 4
1 2  3 4  5 6
*/
```

Для того, чтобы проверить находится ли многоугольник в поле можно воспользоваться функцией:
```c++
pn_field.is_polygon_in_field(pn);
```

Если вы хотите найти пересечение двух многоугольников, воспользуйтесь функцией:
```c++
Polygon res;
Polygon p1;// 1 1 2 2 3 1
Polygon p2;// 2 1 2 2 4 1
PolygonField pn_field;
res = pn_field.intersect_polygons(p1, p2);
res.print_vertices();//Вывод: 2 1 2 2 3 1
```
*Примечание: многоугольники необязательно должны быть членами PolygonField*

Для пересечения поля многоугольников, используйте:
```c++
PolygonField pn_field;
pn_field.intersect_polygon_field();
pn_field.print_field();//Выведутся все многоугольники, получившиеся в результате попарного пересечения
```
Для нахождения итогового пересечения поля многоугольников, используйте:
```c++
PolygonField pn_field;
Polygon res;
res = pn_field.intersect_polygon_field_final();
res.print_vertices();//В выводе будет один из многоугольников с наибольшим количеством пересечений
```
# Работа с файлами
*Здесь будет описание работы с файлами*
